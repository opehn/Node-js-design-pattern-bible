# 종속성 주입 (Dependency Injection)
Node.js의 모듈 시스템과 싱글톤 패턴은 애플리케이션의 컴포넌트들을 구조화하고 연결하는 훌륭한 도구의 역할을 할 수 있다. 
그러나 이것이 항상 성공을 보장하는 것은 아니다. 한편으로는 사용하기 쉽고 매우 실용적이지만, 다른 한편으로는 컴포넌트 간의 결합을 강하게 만들 수 있다.

이전 예시에서 blog.js 모듈은 db.js 모듈과 밀접하게 결합되어 있음을 알 수 있다. 
실제 blog.js 모듈은 설계상 db.js 모듈 없이는 동작할 수 없다. 필요한 경우 다른 데이터베이스 모듈을 사용할 수도 없다. 
종속성 주입 사용하면 두 모듈 간의 긴밀한 결합을 간단하게 수정할 수 있다.

종속성 주입(Dependency Injection)은 컴포넌트들의 종속성이 종종 인젝터(injector)라고 하는 외부 요소에 의해 공급되는 매우 간단한 패턴이다 
인젝터는 다른 컴포넌트를 초기화하고, 종속성들을 함께 연결한다. 
이것은 간단한 초기화를 위한 스크립트일수도, 모든 종속성을 맵핑하여 시스템의 모든 모듈들의 연결을 중압 집중화하는 보다 복잡한 전역 컨테이너일 수도 있다. 
이 접근 ㅂ아식의 주요 장점은 향상된 디커플링인데, 특히 상태 저장 인스턴스(예: 데이터베이스 연결)에 대한 종속성을 가진 모듈들에 유효하다. 
DI를 사용하면 각 종속성이 모듈에 하드코딩되는 대신 외부에서 주입되기 때문이다. 
즉, 종속 모듈은 호환 가능한 종속성을 사용하도록 설정할 수 있으므로 최소한의 노력으로도 다른 컨텍스트에서 재사용할 수 있다.

## 종속성 주입의 단점
코딩 시 종속성을 바로 볼 수 없어 시스템을 구성하는 여러 컴포넌트 간의 관계를 이해하기가 더 어려워진다. 
복잡한 종속성 그래프를 가지는 상상히 큰 서비스가 존재할 수 있는 대규모 애플리케이션에서 특히 두드러지는 특성이다. 
또한 앞선 예제 코드에서 데이터베이스 종속성을 인스턴스화 한 방식을 보면, 
Blog 인스턴스에서 함수를 호출하기 전에 데이터베이스 인스턴스가 생성되었는지를 확인해야 함을 알 수 있다
종속성이 여러개라면 어떻게 될까. 종속성이 올바른 순서대로 주입되도록 전체 애플리케이션의 종속성 그래프를 직접 수동으로 작성해야 하는 어려움이 따른다.

## 제어 역전 (Inversion of Control)
제어 역전이라는 또 다른 패턴을 사용하면 애플리케이션의 모듈들을 연결하는 책임을 제 3의 (third-parth) 엔티티가 하도록 할 수 있다. 
이 엔티티는 서비스 로케이터(종속성을 검색하는 데 사용되는 간단한 컴포넌트로, 예를 들면 serviceLocator.get(db))나 
종속성 주입 컨테이너(코드나 환경 설정 파일에 있는, 어떤 메타데이터 정의를 기반으로 컴포넌트에 종속성을 주입하는 시스템)일 수 있다.
이러한 컴포넌트에 대한 자세한 내용은 Martin Fowler의 블로그 nodejsdp.link/ioc-containers에서 확인할 수 있다.
이러한 기술은 Node.js의 작업 방식에서 약간 벗어나 있지만 일부는 최근 인기를 얻고 있다. 
자세한 내용은 inversify(nodejsdp.link/inversify)및 awilix(nodejsdp.link/awlix) 확인


# 7장 요약
1. 팩토리, 싱글톤 패턴은 OOP에서 가장 널리 사용되는 유형이다. 그러나 JS에서 그 구현 및 중요성은 GoF에서 얘기하는 것과는 다르다. 
팩토리 패턴은 JS 언어의 하이브리드 특성, 즉 절반은 객체지향이고 절반은 함수 기반인 특성과 완벽하게 조화를 이뤄 매우 다목적으로 쓰인다. 
(구현 방법은 OOP 진영과 다름)
싱글톤 패턴은 구현하기가 너무 간단해서 패턴이라 보기 힘들지만 고려할 몇 가지 주의사항이 존재한다. 
-> 싱글톤 패턴에 대해서는 잘 이해가 안되는 부분이 존재했다. 
모듈 시스템으로 싱글톤을 구현하는 것은, 사용자가 클래스 타입 자체를 임포트해서 멋대로 new 할 가능성을 완전히 없앨 수가 없다
또 싱글톤의 단점이 결합도가 높아지는 것이라 했는데 싱글톤 + DI의 조합으로 해결할 수 있는 부분이라는 점에서
싱글톤이 문제가 아니라 DI를 쓰지 않는게 문제인게 아닌가 싶었다
책에서는 instance의 유무를 검사해 없을 때만 create 한다던가, 하는 코드를 소개하지 않아서
싱글톤  -> 팩토리 함수 (인스턴스 여러개 생성 가능)으로 바꾸는 작업이 DI로의 리팩토링에 포함되어 있었는데
결국 DI를 하려면 싱글톤을 팩토리로 바꿔야 하고 팩토리로 바꾸면 인스턴스를 여러개 생성하게 되므로 안된다. 인것같은데..
인스턴스를 static이든 전역 컨테이너에 넣든 전역으로 두고 팩토리 함수에서 new 할 때 마다 존재 유무를 검사하면 되는데 
왜 싱글톤의 단점이 DI가 안되는 것인지 모르겠다. 
좀 더 공부하다보면 알 수 있을지도.. 

빌더 패턴은 기존의 객체 지향 형식의 대부분을 그대로 유지한 것처럼 보일 수 있지만, 
객체를 만드는 것뿐만 아니라 복잡한 함수를 호출하는데도 사용할 수 있다. 

공개 생성자 패턴은 그 자체로 범주를 차지할 만한 중요한 패턴이다. 
생성시에만 프라이빗 객체 속성을 노출해야 하는 문제에 대한 매끄러운 해결책을 제공한다.

마지막으로 컴포넌트를 연결하는 두 가지 중요한 기술에 대해 살펴보았다. 
싱글톤은 간단하고 실용적이지만 결합도가 높아 유지보수가 어렵고,
종속성 주입은 이러한 문제를 해결하지만 구현의 복잡도가 높다는 것을 알았다.

